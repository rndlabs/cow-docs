"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[3037],{3905:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>k});var r=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,r,a=function(e,t){if(null==e)return{};var o,r,a={},n=Object.keys(e);for(r=0;r<n.length;r++)o=n[r],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var o=e.components,a=e.mdxType,n=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(o),h=a,k=c["".concat(s,".").concat(h)]||c[h]||d[h]||n;return o?r.createElement(k,i(i({ref:t},u),{},{components:o})):r.createElement(k,i({ref:t},u))}));function k(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var n=o.length,i=new Array(n);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<n;p++)i[p]=o[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,o)}h.displayName="MDXCreateElement"},9951:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>n,metadata:()=>l,toc:()=>p});var r=o(7462),a=(o(7294),o(3905));const n={},i="How to write a solver",l={unversionedId:"tutorials/how-to-write-a-solver",id:"tutorials/how-to-write-a-solver",title:"How to write a solver",description:"This tutorial was fully composed by poolpitako, link to the original tutorial doc can be found here",source:"@site/docs/5_tutorials/7_how-to-write-a-solver.md",sourceDirName:"5_tutorials",slug:"/tutorials/how-to-write-a-solver",permalink:"/cow-docs/docs/tutorials/how-to-write-a-solver",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/5_tutorials/7_how-to-write-a-solver.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Solver Workshop",permalink:"/cow-docs/docs/tutorials/solver-workshop"},next:{title:"How to place ERC-1271 (Smart Contract) orders",permalink:"/cow-docs/docs/category/how-to-place-erc-1271-smart-contract-orders"}},s={},p=[{value:"This tutorial was fully composed by poolpitako, link to the original tutorial doc can be found here",id:"this-tutorial-was-fully-composed-by-poolpitako-link-to-the-original-tutorial-doc-can-be-found-here",level:2},{value:"Idea",id:"idea",level:3},{value:"The Big Picture",id:"the-big-picture",level:3},{value:"The Orderbook",id:"the-orderbook",level:4},{value:"The Driver",id:"the-driver",level:4},{value:"Solver",id:"solver",level:4},{value:"The most basic setup",id:"the-most-basic-setup",level:3},{value:"Settling Real Orders",id:"settling-real-orders",level:3},{value:"Full E2E testing",id:"full-e2e-testing",level:3},{value:"My solver code",id:"my-solver-code",level:3},{value:"Conclusion",id:"conclusion",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...o}=e;return(0,a.kt)(c,(0,r.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"how-to-write-a-solver"},"How to write a solver"),(0,a.kt)("h2",{id:"this-tutorial-was-fully-composed-by-poolpitako-link-to-the-original-tutorial-doc-can-be-found-here"},"This tutorial was fully composed by ",(0,a.kt)("a",{parentName:"h2",href:"https://twitter.com/poolpitako"},"poolpitako"),", link to the original tutorial doc can be found ",(0,a.kt)("a",{parentName:"h2",href:"https://hackmd.io/Qx3i17ZMRLSFFNyw0tn8sQ?view"},"here")),(0,a.kt)("h3",{id:"idea"},"Idea"),(0,a.kt)("p",null,"I wanted to start with something super basic to understand all the moving pieces. In my example, I am going to build a solver for Yearn tokens. User has a token, let\u2019s say, ",(0,a.kt)("inlineCode",{parentName:"p"},"USDC")," and wants to buy ",(0,a.kt)("inlineCode",{parentName:"p"},"yvUSDC"),". Right now, CoW Swap would need a LP ",(0,a.kt)("inlineCode",{parentName:"p"},"USDC/yvUSDC")," to settle the trade, but what if the solver understands how to deposit into a yearn vault? ! \ud83e\udd14"),(0,a.kt)("h3",{id:"the-big-picture"},"The Big Picture"),(0,a.kt)("p",null,"CoW Swap infrastructure is a lot of services running together, which is a bit intimidating at the beginning. Here\u2019s the ELI5 of how CoW Swap works and it\u2019s entities."),(0,a.kt)("h4",{id:"the-orderbook"},"The Orderbook"),(0,a.kt)("p",null,"The orderbook is a service that uses a database to stores trades."),(0,a.kt)("p",null,"When you go to ",(0,a.kt)("a",{parentName:"p",href:"https://swap.cow.fi/"},"https://swap.cow.fi/")," and create a trade, the website uses the orderbook API to add the trade to the database. If the trade is ready to go (it might be created but missing a signature), it will be listed in the ",(0,a.kt)("inlineCode",{parentName:"p"},"solvable_orders")," endpoint."),(0,a.kt)("h4",{id:"the-driver"},"The Driver"),(0,a.kt)("p",null,"The driver is a polling service that queries the orderbook API for orders and tries to settle them using the different solvers. The driver calls different solvers by using an http API. The driver prunes the orderbook ",(0,a.kt)("inlineCode",{parentName:"p"},"solvable_orders")," and sends orders, in JSON, to the different solvers. If a solver finds a solution to the batch, the driver executes the trade on chain."),(0,a.kt)("h4",{id:"solver"},"Solver"),(0,a.kt)("p",null,"The solver is a standalone service which receives a JSON with orders and tries to settle them."),(0,a.kt)("p",null,"The settlement can be a list of actions which are executed by the settlement contract on chain."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Warning"),": I assume you have rust setup correctly with rustup."),(0,a.kt)("h3",{id:"the-most-basic-setup"},"The most basic setup"),(0,a.kt)("p",null,"Let\u2019s start simple. Let\u2019s first run a solver which solves a JSON we send by hand with curl."),(0,a.kt)("p",null,"Start by cloning ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gnosis/cow-dex-solver"},"https://github.com/gnosis/cow-dex-solver")),(0,a.kt)("p",null,"cow-dex-solver will give you a good idea of how a solver service is architected."),(0,a.kt)("p",null,"You have a method called ",(0,a.kt)("inlineCode",{parentName:"p"},"solve()")," which receives the batch ",(0,a.kt)("inlineCode",{parentName:"p"},"orders")," and returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"SettledBatchAuctionModel")," aka a solution."),(0,a.kt)("p",null,"To run, exec:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"cargo run -v \n")),(0,a.kt)("p",null,"Once the service is running you can start throwing JSONs at it."),(0,a.kt)("p",null,"I started reading the code and playing with different JSON setups calling:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'curl -vX POST "http://127.0.0.1:8000/solve" -H  "accept: application/json" -H  "Content-Type: application/json" --data "@/Users/user/dev/cow-dex-solver/sample.json"\n')),(0,a.kt)("p",null,"You can get some inspiration from prod examples here:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://gnosis-europe-gpv2-solver.s3-website.eu-central-1.amazonaws.com/index.html#data/prod/2022/01/"},"http://gnosis-europe-gpv2-solver.s3-website.eu-central-1.amazonaws.com/index.html#data/prod/2022/01/")),(0,a.kt)("p",null,"Make sure to test what happens when there is a CoW ! \ud83d\udc2e"),(0,a.kt)("h3",{id:"settling-real-orders"},"Settling Real Orders"),(0,a.kt)("p",null,"Once I understood how a solver works, I wanted to solve a real order. To test this out without setting up the orderbook I used a little trick. I created an order in a production orderbook but I setup an impossible limit order. For that I used the staging orderbook in the Gnosis Chain. I deployed a yvUSDC vault, and I created an LP USDC/yvUSDC in Honeyswap."),(0,a.kt)("p",null,"You have different options to create a limit oder:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.cow.fi/tutorials/cowswap-trades-with-a-gnosis-safe-wallet"},"https://docs.cow.fi/tutorials/cowswap-trades-with-a-gnosis-safe-wallet")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://bafybeias5x3tgdshkhj5umriqze2wioy5mjw4fdo2zzp2sl4pacq7rnwtm.ipfs.infura-ipfs.io/?orderbook=https://barn.api.cow.fi/xdai"},"https://bafybeias5x3tgdshkhj5umriqze2wioy5mjw4fdo2zzp2sl4pacq7rnwtm.ipfs.infura-ipfs.io/?orderbook=https://barn.api.cow.fi/xdai")),(0,a.kt)("li",{parentName:"ul"},"You call the API by hand")),(0,a.kt)("p",null,"Here\u2019s the example I created while testing:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://barn.gnosis-protocol.io/gc/orders/0xcc37de3ba70474948f838e8b4af9c6b66577c08202323a4a3060a645b2918dae2813a7e97fd0bc1b80cb63afe136510d940ddc236208633c"},"https://barn.gnosis-protocol.io/gc/orders/0xcc37de3ba70474948f838e8b4af9c6b66577c08202323a4a3060a645b2918dae2813a7e97fd0bc1b80cb63afe136510d940ddc236208633c")),(0,a.kt)("p",null,"I am trading 10 USDC for 91.412 yvUSDC, which of course, will never settle by regular solvers since 1 ",(0,a.kt)("inlineCode",{parentName:"p"},"USDC == 1 yvUSDC")," (price per share is 1)."),(0,a.kt)("p",null,"Now that we have the real order, the orderbook will return it in the ",(0,a.kt)("inlineCode",{parentName:"p"},"solvable_orders")," endpoint."),(0,a.kt)("p",null,"To consume it, we will need to use the driver."),(0,a.kt)("p",null,"The cow-dex-solver repo now has a nice README with an explanation of how to run the driver:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/gnosis/cow-dex-solver#how-to-run-simulations-together-with-the-cowswap-official-driver"},"https://github.com/gnosis/cow-dex-solver#how-to-run-simulations-together-with-the-cowswap-official-driver")),(0,a.kt)("p",null,"The way I was it running was:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'cargo run -p solver --  --orderbook-url https://protocol-xdai.dev.gnosisdev.com \\\n     --base-tokens 0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83 \\\n     --node-url "https://rpc.xdaichain.com" \\\n     --cow-dex-ag-solver-url "http://127.0.0.1:8000" \\\n    --solver-account 0x7942a2b3540d1ec40b2740896f87aecb2a588731 \\\n    --solvers CowDexAg \\\n    --transaction-strategy DryRun\n')),(0,a.kt)("p",null,"A small explanation of the parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"orderbook-url"),": points to the CoW Protocol staging version"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"node-url")," connects to Gnosis Chain (VERY IMPORTANT, liquidity sources are based on this)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"cow-dex-ag-solver-url")," our running solver instance"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"solver-account")," An address that has permissions to run TXs in the settlement contract"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"solvers")," just use our CowDexAg instance"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"transaction-strategy")," DryRun will give us a tenderly link after running")),(0,a.kt)("p",null,"If you got to this point, you have 99% of stuff you need to write your solver."),(0,a.kt)("p",null,"Until the trade expires, the solver will always find the crazy limit order and send it to your solver. If the solver responds with a solution, the driver will spit out a tenderly link with the execution simulation."),(0,a.kt)("h3",{id:"full-e2e-testing"},"Full E2E testing"),(0,a.kt)("p",null,"Is your solver working and you want to try a more real order?"),(0,a.kt)("p",null,"You will need to run your own orderbook. For that, you will need docker."),(0,a.kt)("p",null,"Follow the steps at: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gnosis/gp-v2-services/#db-migrationinitialization"},"https://github.com/gnosis/gp-v2-services/#db-migrationinitialization")),(0,a.kt)("p",null,"I run my orderbook with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'cargo run --bin orderbook -- \\\n  --skip-trace-api true \\\n  --skip-event-sync \\\n  --base-tokens 0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83 \\\n  --enable-presign-orders true \\\n  --node-url "https://rpc.xdaichain.com"\n')),(0,a.kt)("p",null,"and created an order using ",(0,a.kt)("a",{parentName:"p",href:"https://bafybeias5x3tgdshkhj5umriqze2wioy5mjw4fdo2zzp2sl4pacq7rnwtm.ipfs.infura-ipfs.io/?orderbook=http://localhost:8080"},"https://bafybeias5x3tgdshkhj5umriqze2wioy5mjw4fdo2zzp2sl4pacq7rnwtm.ipfs.infura-ipfs.io/?orderbook=http://localhost:8080")),(0,a.kt)("p",null,"The last step is connecting the driver to the new orderbook local service doing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'cargo run -p solver --  --orderbook-url http://localhost:8080 \\\n     --base-tokens 0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83 \\\n     --node-url "https://rpc.xdaichain.com" \\\n     --cow-dex-ag-solver-url "http://127.0.0.1:8000" \\\n    --solver-account 0x7942a2b3540d1ec40b2740896f87aecb2a588731 \\\n    --solvers CowDexAg \\\n    --transaction-strategy DryRun\n')),(0,a.kt)("p",null,"Full process will be:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Orderbook at ",(0,a.kt)("a",{parentName:"li",href:"http://localhost:8080/"},"http://localhost:8080")," is returning your oder in the ",(0,a.kt)("inlineCode",{parentName:"li"},"solvable_orders")," endpoint"),(0,a.kt)("li",{parentName:"ul"},"Driver will fetch orders from your orderbook and query your"),(0,a.kt)("li",{parentName:"ul"},"Solver at ",(0,a.kt)("a",{parentName:"li",href:"http://localhost:8000/"},"http://localhost:8000"))),(0,a.kt)("h3",{id:"my-solver-code"},"My solver code"),(0,a.kt)("p",null,"I forked cow-dex-solver and wrote my first lines of rust."),(0,a.kt)("p",null,"You can checkout my solver\u2019s code at:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/poolpitako/cow-dex-solver/pull/1"},"https://github.com/poolpitako/cow-dex-solver/pull/1")),(0,a.kt)("h3",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"While there are several services you need to run for an E2E testing, I gotta say I enjoyed developing this prototype. I believe that in the future CoW Swap will not only be used for regular trades but it will be used for settling positions. Want to add liquidity to a curve pool in a single click? Go to CoW Swap. Want to swap your DAI for two yearn vault positions, go to CoW Swap! \ud83d\udc2e\ud83d\udc2e\ud83d\udc2e\ud83d\udc2e\ud83d\udc2e\ud83d\udc2e"))}d.isMDXComponent=!0}}]);