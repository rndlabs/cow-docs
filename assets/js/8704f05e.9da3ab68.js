"use strict";(self.webpackChunkcow_docs=self.webpackChunkcow_docs||[]).push([[8995],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>m});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var i=n.createContext({}),d=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},l=function(e){var t=d(e.components);return n.createElement(i.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(r),f=o,m=p["".concat(i,".").concat(f)]||p[f]||u[f]||a;return r?n.createElement(m,c(c({ref:t},l),{},{components:r})):n.createElement(m,c({ref:t},l))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,c=new Array(a);c[0]=f;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:o,c[1]=s;for(var d=2;d<a;d++)c[d]=r[d];return n.createElement.apply(null,c)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},4067:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var n=r(7462),o=(r(7294),r(3905));const a={},c="Orders in Storage",s={unversionedId:"smart-contracts/eth-flow-contract/orders-in-storage",id:"smart-contracts/eth-flow-contract/orders-in-storage",title:"Orders in Storage",description:"The eth-flow contract stores user orders as a mapping:",source:"@site/docs/3_smart-contracts/eth-flow-contract/5_orders-in-storage.md",sourceDirName:"3_smart-contracts/eth-flow-contract",slug:"/smart-contracts/eth-flow-contract/orders-in-storage",permalink:"/cow-docs/docs/smart-contracts/eth-flow-contract/orders-in-storage",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3_smart-contracts/eth-flow-contract/5_orders-in-storage.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"User and ETH Flow Contract Orders",permalink:"/cow-docs/docs/smart-contracts/eth-flow-contract/user-and-eth-flow-contract-orders"},next:{title:"Order Creation",permalink:"/cow-docs/docs/smart-contracts/eth-flow-contract/order-creation"}},i={},d=[],l={toc:d},p="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"orders-in-storage"},"Orders in Storage"),(0,o.kt)("p",null,"The eth-flow contract stores user orders as a mapping:"),(0,o.kt)("p",null,"order digest -> | either userAddress || userValidTo"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"                \\| or     0x00\u202600     || anything (unset)\n\n                \\| or     0xff\u2026ff     || anything (invalidated)\n")),(0,o.kt)("p",null,"The same user can have multiple open orders."),(0,o.kt)("p",null,"Every ",(0,o.kt)("inlineCode",{parentName:"p"},"order digest")," represents a single order in the eth-flow contract. It is computed by computing the CoW Swap order digest from the contract order that is derived from the user order parameters."),(0,o.kt)("p",null,"There could be two different eth-flow orders that end up having the same digest. In this case, only one of the two orders can be created and the contract would revert if trying to create the second one."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"userValidTo")," is the validity of the user order (note that changing the validity does not change the order digest)."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"userAddress")," is the address of the user who owns the order."))}u.isMDXComponent=!0}}]);